#!/usr/bin/env python3
"""
GCP Vulnerability Scanner Automation System
Author: Security Team
Version: 1.0.0
"""

import google.auth
from google.cloud import compute_v1
from google.cloud import storage
from google.cloud import securitycenter_v1
from google.cloud import asset_v1
from google.cloud import osconfig_v1
from google.cloud import container_v1
from google.cloud.sql.connector import Connector
from google.cloud import secretmanager
from google.cloud import pubsub_v1
from google.cloud import bigquery
import googleapiclient.discovery
from google.oauth2 import service_account

import asyncio
import aiohttp
import json
import yaml
import pandas as pd
from datetime import datetime, timedelta
from dataclasses import dataclass
from typing import List, Dict, Optional, Any
import logging
from logging.handlers import RotatingFileHandler
import sys
import os
from pathlib import Path
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import smtplib

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        RotatingFileHandler('gcp_vulnerability_scanner.log', maxBytes=10*1024*1024, backupCount=5),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class Vulnerability:
    """Vulnerability data class for GCP"""
    id: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW, INFO
    title: str
    description: str
    cvss_score: float
    cve_id: Optional[str]
    affected_resource: str
    resource_type: str  # GCE, GKE, CloudSQL, GCS, etc.
    project_id: str
    zone: str
    detection_date: datetime
    remediation: str
    references: List[str]
    category: str  # VULNERABILITY, MISCONFIGURATION, etc.

# class OrganizationScanner:
#     """Scanner for multiple GCP projects"""
    
#     def __init__(self, organization_id):
#         self.organization_id = organization_id
#         self.projects = self.get_all_projects()
    
#     async def scan_organization(self):
#         """Scan all projects in organization"""
#         results = []
        
#         for project_id in self.projects:
#             logger.info(f"Scanning project: {project_id}")
            
#             # Create scanner for each project
#             scanner = GCPVulnerabilityScanner(project_id)
#             project_results = await scanner.scan_all_resources()
#             results.extend(project_results)
        
#         return results
    
#     def get_all_projects(self):
#         """Get all projects in organization"""
#         from google.cloud import resourcemanager_v3
        
#         client = resourcemanager_v3.ProjectsClient()
        
#         projects = []
#         request = resourcemanager_v3.ListProjectsRequest(
#             parent=f"organizations/{self.organization_id}"
#         )
        
#         for project in client.list_projects(request=request):
#             projects.append(project.project_id)
        
#         return projects


class GCPVulnerabilityScanner:
    """Main GCP scanner class"""
    
    def __init__(self, config_path: str = "config_gcp.yaml"):
        """Initialize scanner with configuration"""
        self.config = self.load_config(config_path)
        self.credentials, self.project_id = self.authenticate()
        self.results: List[Vulnerability] = []
        self.setup_clients()
        
    def load_config(self, config_path: str) -> Dict:
        """Load configuration from YAML file"""
        config_path = Path(config_path)
        if not config_path.exists():
            logger.error(f"Config file not found: {config_path}")
            raise FileNotFoundError(f"Config file not found: {config_path}")
        
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        
        # Set defaults
        defaults = {
            'scan_frequency': 'daily',
            'severity_threshold': 'MEDIUM',
            'excluded_projects': [],
            'notification_channels': ['email', 'pubsub'],
            'report_formats': ['html', 'csv', 'json'],
            'retention_days': 90,
            'regions': ['us-central1', 'us-east1', 'us-west1', 'europe-west1', 'asia-east1']
        }
        
        return {**defaults, **config}
    
    def authenticate(self):
        """Authenticate with GCP"""
        try:
            # Try Application Default Credentials first
            credentials, project = google.auth.default()
            
            # If service account key is provided
            if self.config.get('service_account_key_path'):
                credentials = service_account.Credentials.from_service_account_file(
                    self.config['service_account_key_path']
                )
                project = self.config.get('project_id', project)
            
            logger.info(f"Authenticated to project: {project}")
            return credentials, project
            
        except Exception as e:
            logger.error(f"Authentication failed: {e}")
            raise
    
    def setup_clients(self):
        """Initialize GCP service clients"""
        self.compute_client = compute_v1.InstancesClient(credentials=self.credentials)
        self.storage_client = storage.Client(credentials=self.credentials, project=self.project_id)
        self.security_center_client = securitycenter_v1.SecurityCenterClient(credentials=self.credentials)
        self.asset_client = asset_v1.AssetServiceClient(credentials=self.credentials)
        self.osconfig_client = osconfig_v1.OsConfigZonalServiceClient(credentials=self.credentials)
        self.container_client = container_v1.ClusterManagerClient(credentials=self.credentials)
        self.secret_manager_client = secretmanager.SecretManagerServiceClient(credentials=self.credentials)
        self.pubsub_client = pubsub_v1.PublisherClient(credentials=self.credentials)
        self.bigquery_client = bigquery.Client(credentials=self.credentials, project=self.project_id)
        
        # Service Usage API for listing enabled services
        self.service_usage_client = googleapiclient.discovery.build(
            'serviceusage', 'v1', credentials=self.credentials
        )
        
        # Cloud SQL Admin API
        self.sql_client = googleapiclient.discovery.build(
            'sqladmin', 'v1beta4', credentials=self.credentials
        )

    # async def get_all_resources(self, asset_types=None):
    # """Get all resources using Cloud Asset Inventory"""
    # resources = []
    
    # # Use Cloud Asset Inventory to discover resources
    # request = asset_v1.SearchAllResourcesRequest(
    #     scope=f"projects/{self.project_id}",
    #     asset_types=asset_types or [
    #         "compute.googleapis.com/Instance",
    #         "sqladmin.googleapis.com/Instance",
    #         "storage.googleapis.com/Bucket",
    #         "container.googleapis.com/Cluster"
    #     ],
    #     page_size=1000
    # )
    
    # # Stream all resources
    # client = asset_v1.AssetServiceClient()
    # for resource in client.search_all_resources(request=request):
    #     resources.append(resource)
    
    # return resources

    
    async def scan_all_resources(self):
        """Orchestrate scanning of all GCP resources"""
        logger.info(f"Starting comprehensive vulnerability scan for project: {self.project_id}")
        
        # Get all projects in organization if specified
        projects = await self.get_target_projects()
        
        scan_tasks = []
        for project in projects:
            scan_tasks.extend([
                self.scan_compute_instances(project),
                self.scan_cloud_sql_instances(project),
                self.scan_gcs_buckets(project),
                self.scan_gke_clusters(project),
                self.scan_vpc_networks(project),
                self.scan_iam_policies(project),
                self.scan_cloud_functions(project),
                self.scan_app_engine(project),
                self.scan_firewall_rules(project),
                self.scan_cloud_run(project),
            ])
        
        # Execute all scans concurrently
        results = await asyncio.gather(*scan_tasks, return_exceptions=True)
        
        # Process results
        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Scan task failed: {result}")
            elif result:
                self.results.extend(result)
        
        # Run Security Command Center findings
        scc_findings = await self.get_security_command_center_findings()
        self.results.extend(scc_findings)
        
        logger.info(f"Scan completed. Found {len(self.results)} vulnerabilities")
        return self.results
    
    async def get_target_projects(self) -> List[str]:
        """Get list of projects to scan"""
        if self.config.get('scan_all_projects', False) and self.config.get('organization_id'):
            # Use Cloud Asset Inventory to get all projects in organization
            request = asset_v1.ListAssetsRequest(
                parent=f"organizations/{self.config['organization_id']}",
                asset_types=["cloudresourcemanager.googleapis.com/Project"],
                content_type=asset_v1.ContentType.RESOURCE
            )
            
            try:
                response = self.asset_client.list_assets(request=request)
                projects = [asset.name.split('/')[-1] for asset in response]
                return projects
            except Exception as e:
                logger.error(f"Failed to list projects: {e}")
        
        # Return current project or configured projects
        return self.config.get('projects', [self.project_id])
    
    async def scan_compute_instances(self, project_id: str) -> List[Vulnerability]:
        """Scan Compute Engine instances for vulnerabilities"""
        logger.info(f"Scanning Compute Engine instances in project: {project_id}")
        vulnerabilities = []
        
        try:
            for zone in self.config['regions']:
                # List all instances in the zone
                request = compute_v1.ListInstancesRequest(
                    project=project_id,
                    zone=zone
                )
                
                try:
                    instances = self.compute_client.list(request=request)
                    
                    for instance in instances:
                        instance_name = instance.name
                        
                        # Check for Shielded VM features
                        if not instance.shielded_instance_config.enable_vtpm or \
                           not instance.shielded_instance_config.enable_integrity_monitoring:
                            vuln = Vulnerability(
                                id=f"GCE-{instance_name}-NO-SHIELDED-VM",
                                severity="HIGH",
                                title="Shielded VM Not Enabled",
                                description=f"Compute Engine instance {instance_name} does not have Shielded VM features enabled",
                                cvss_score=7.5,
                                cve_id=None,
                                affected_resource=instance_name,
                                resource_type="ComputeEngine",
                                project_id=project_id,
                                zone=zone,
                                detection_date=datetime.now(),
                                remediation="Enable Shielded VM features (vTPM and Integrity Monitoring)",
                                references=["https://cloud.google.com/security/shielded-cloud/shielded-vm"],
                                category="MISCONFIGURATION"
                            )
                            vulnerabilities.append(vuln)
                        
                        # Check for OS patch compliance
                        if not await self.check_os_patch_compliance(project_id, zone, instance_name):
                            vuln = Vulnerability(
                                id=f"GCE-{instance_name}-UNPATCHED",
                                severity="MEDIUM",
                                title="OS Patching Not Compliant",
                                description=f"Compute Engine instance {instance_name} is not compliant with OS patching policy",
                                cvss_score=6.0,
                                cve_id=None,
                                affected_resource=instance_name,
                                resource_type="ComputeEngine",
                                project_id=project_id,
                                zone=zone,
                                detection_date=datetime.now(),
                                remediation="Apply OS patches or configure OS Config management",
                                references=["https://cloud.google.com/compute/docs/os-config-management"],
                                category="VULNERABILITY"
                            )
                            vulnerabilities.append(vuln)
                        
                        # Check if instance has public IP
                        for interface in instance.network_interfaces:
                            for config in interface.access_configs:
                                if config.nat_i_p:
                                    # Instance has public IP
                                    vuln = Vulnerability(
                                        id=f"GCE-{instance_name}-PUBLIC-IP",
                                        severity="MEDIUM",
                                        title="Instance with Public IP",
                                        description=f"Compute Engine instance {instance_name} has a public IP address",
                                        cvss_score=5.0,
                                        cve_id=None,
                                        affected_resource=instance_name,
                                        resource_type="ComputeEngine",
                                        project_id=project_id,
                                        zone=zone,
                                        detection_date=datetime.now(),
                                        remediation="Consider using Cloud NAT or removing public IP if not needed",
                                        references=["https://cloud.google.com/vpc/docs/configure-private-google-access"],
                                        category="MISCONFIGURATION"
                                    )
                                    vulnerabilities.append(vuln)
                                    break
                        
                        # Check disk encryption
                        for disk in instance.disks:
                            if not disk.disk_encryption_key:
                                vuln = Vulnerability(
                                    id=f"GCE-{instance_name}-UNENCRYPTED-DISK",
                                    severity="HIGH",
                                    title="Unencrypted Disk",
                                    description=f"Compute Engine instance {instance_name} has unencrypted disk: {disk.device_name}",
                                    cvss_score=7.0,
                                    cve_id=None,
                                    affected_resource=instance_name,
                                    resource_type="ComputeEngine",
                                    project_id=project_id,
                                    zone=zone,
                                    detection_date=datetime.now(),
                                    remediation="Enable customer-managed encryption keys (CMEK)",
                                    references=["https://cloud.google.com/compute/docs/disks/customer-managed-encryption"],
                                    category="MISCONFIGURATION"
                                )
                                vulnerabilities.append(vuln)
                
                except Exception as e:
                    logger.warning(f"Error listing instances in zone {zone}: {e}")
                    continue
        
        except Exception as e:
            logger.error(f"Error scanning Compute Engine instances: {e}")
        
        return vulnerabilities

    # async def check_os_vulnerabilities(self, instance_name, zone):
    # """Check OS vulnerabilities using OS Config"""
    # request = osconfig_v1.GetVulnerabilityReportRequest(
    #     name=f"projects/{self.project_id}/zones/{zone}/instances/{instance_name}/vulnerabilityReport"
    # )
    
    # try:
    #     report = self.osconfig_client.get_vulnerability_report(request=request)
        
    #     vulnerabilities = []
    #     for vuln in report.vulnerabilities:
    #         vulnerability = Vulnerability(
    #             id=vuln.cve_id,
    #             severity=self.map_severity(vuln.cvss_v3.base_score),
    #             title=vuln.title,
    #             description=vuln.description,
    #             cvss_score=vuln.cvss_v3.base_score,
    #             cve_id=vuln.cve_id,
    #             affected_resource=instance_name,
    #             resource_type="ComputeEngine",
    #             project_id=self.project_id,
    #             zone=zone,
    #             detection_date=datetime.now(),
    #             remediation="Apply available OS patches",
    #             references=[vuln.references],
    #             category="VULNERABILITY"
    #         )
    #         vulnerabilities.append(vulnerability)
        
    #     return vulnerabilities
        
    # except Exception as e:
    #     logger.warning(f"No vulnerability report for {instance_name}: {e}")
    #     return []

    
    async def check_os_patch_compliance(self, project_id: str, zone: str, instance_name: str) -> bool:
        """Check OS patch compliance using OS Config"""
        try:
            # Get OS Config inventory
            request = osconfig_v1.GetInventoryRequest(
                name=f"projects/{project_id}/zones/{zone}/instances/{instance_name}/inventory"
            )
            
            inventory = self.osconfig_client.get_inventory(request=request)
            
            # Check for available patches
            if inventory.available_packages and len(inventory.available_packages) > 10:
                # Too many available patches indicates non-compliance
                return False
            
            return True
            
        except Exception as e:
            logger.warning(f"Failed to check OS patch compliance for {instance_name}: {e}")
            return False
    
    async def scan_cloud_sql_instances(self, project_id: str) -> List[Vulnerability]:
        """Scan Cloud SQL instances for vulnerabilities"""
        logger.info(f"Scanning Cloud SQL instances in project: {project_id}")
        vulnerabilities = []
        
        try:
            # List Cloud SQL instances
            response = self.sql_client.instances().list(project=project_id).execute()
            
            for instance in response.get('items', []):
                instance_name = instance['name']
                
                # Check for public IP
                if instance.get('settings', {}).get('ipConfiguration', {}).get('ipv4Enabled', False):
                    vuln = Vulnerability(
                        id=f"CloudSQL-{instance_name}-PUBLIC-IP",
                        severity="CRITICAL",
                        title="Cloud SQL Instance with Public IP",
                        description=f"Cloud SQL instance {instance_name} has public IP enabled",
                        cvss_score=9.0,
                        cve_id=None,
                        affected_resource=instance_name,
                        resource_type="CloudSQL",
                        project_id=project_id,
                        zone=instance.get('region', 'unknown'),
                        detection_date=datetime.now(),
                        remediation="Disable public IP and use private IP or Cloud SQL Proxy",
                        references=["https://cloud.google.com/sql/docs/mysql/configure-private-ip"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check SSL enforcement
                if not instance.get('settings', {}).get('ipConfiguration', {}).get('requireSsl', False):
                    vuln = Vulnerability(
                        id=f"CloudSQL-{instance_name}-NO-SSL",
                        severity="HIGH",
                        title="SSL Not Required for Cloud SQL",
                        description=f"Cloud SQL instance {instance_name} does not require SSL connections",
                        cvss_score=7.5,
                        cve_id=None,
                        affected_resource=instance_name,
                        resource_type="CloudSQL",
                        project_id=project_id,
                        zone=instance.get('region', 'unknown'),
                        detection_date=datetime.now(),
                        remediation="Enable 'require_ssl' flag for Cloud SQL instance",
                        references=["https://cloud.google.com/sql/docs/mysql/configure-ssl-instance"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check automated backups
                if not instance.get('settings', {}).get('backupConfiguration', {}).get('enabled', False):
                    vuln = Vulnerability(
                        id=f"CloudSQL-{instance_name}-NO-BACKUPS",
                        severity="MEDIUM",
                        title="Automated Backups Not Enabled",
                        description=f"Cloud SQL instance {instance_name} does not have automated backups enabled",
                        cvss_score=5.0,
                        cve_id=None,
                        affected_resource=instance_name,
                        resource_type="CloudSQL",
                        project_id=project_id,
                        zone=instance.get('region', 'unknown'),
                        detection_date=datetime.now(),
                        remediation="Enable automated backups for Cloud SQL instance",
                        references=["https://cloud.google.com/sql/docs/mysql/backup-recovery/backups"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check database flags for security
                db_flags = instance.get('settings', {}).get('databaseFlags', [])
                flag_names = {flag['name'] for flag in db_flags}
                
                # Check for local_infile (MySQL security)
                if 'local_infile' in flag_names:
                    for flag in db_flags:
                        if flag['name'] == 'local_infile' and flag.get('value') == 'on':
                            vuln = Vulnerability(
                                id=f"CloudSQL-{instance_name}-LOCAL-INFILE",
                                severity="MEDIUM",
                                title="local_infile Enabled in MySQL",
                                description=f"Cloud SQL MySQL instance {instance_name} has local_infile enabled",
                                cvss_score=6.0,
                                cve_id=None,
                                affected_resource=instance_name,
                                resource_type="CloudSQL",
                                project_id=project_id,
                                zone=instance.get('region', 'unknown'),
                                detection_date=datetime.now(),
                                remediation="Disable local_infile flag for improved security",
                                references=["https://dev.mysql.com/doc/refman/8.0/en/load-data-local-security.html"],
                                category="MISCONFIGURATION"
                            )
                            vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning Cloud SQL instances: {e}")
        
        return vulnerabilities
    
    async def scan_gcs_buckets(self, project_id: str) -> List[Vulnerability]:
        """Scan Cloud Storage buckets for misconfigurations"""
        logger.info(f"Scanning Cloud Storage buckets in project: {project_id}")
        vulnerabilities = []
        
        try:
            # List all buckets (including non-project buckets)
            buckets = list(self.storage_client.list_buckets())
            
            for bucket in buckets:
                bucket_name = bucket.name
                
                # Skip buckets not in target project if configured
                if self.config.get('scan_only_project_buckets', True):
                    if bucket.project_number != self.storage_client.project:
                        continue
                
                # Check IAM policy for public access
                try:
                    policy = bucket.get_iam_policy()
                    
                    for binding in policy.bindings:
                        if 'allUsers' in binding.members or 'allAuthenticatedUsers' in binding.members:
                            vuln = Vulnerability(
                                id=f"GCS-{bucket_name}-PUBLIC-ACCESS",
                                severity="CRITICAL",
                                title="Public Cloud Storage Bucket",
                                description=f"Cloud Storage bucket {bucket_name} allows public access",
                                cvss_score=9.5,
                                cve_id=None,
                                affected_resource=bucket_name,
                                resource_type="CloudStorage",
                                project_id=project_id,
                                zone='global',
                                detection_date=datetime.now(),
                                remediation="Remove allUsers and allAuthenticatedUsers from bucket IAM policy",
                                references=["https://cloud.google.com/storage/docs/access-control/iam"],
                                category="MISCONFIGURATION"
                            )
                            vulnerabilities.append(vuln)
                            break
                
                except Exception as e:
                    logger.warning(f"Failed to check IAM policy for bucket {bucket_name}: {e}")
                
                # Check uniform bucket-level access
                if not bucket.iam_configuration.uniform_bucket_level_access_enabled:
                    vuln = Vulnerability(
                        id=f"GCS-{bucket_name}-NO-UNIFORM-ACCESS",
                        severity="HIGH",
                        title="Uniform Bucket-Level Access Not Enabled",
                        description=f"Cloud Storage bucket {bucket_name} does not have uniform bucket-level access enabled",
                        cvss_score=7.0,
                        cve_id=None,
                        affected_resource=bucket_name,
                        resource_type="CloudStorage",
                        project_id=project_id,
                        zone='global',
                        detection_date=datetime.now(),
                        remediation="Enable uniform bucket-level access",
                        references=["https://cloud.google.com/storage/docs/uniform-bucket-level-access"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check default encryption
                if not bucket.default_kms_key_name:
                    vuln = Vulnerability(
                        id=f"GCS-{bucket_name}-NO-CMEK",
                        severity="MEDIUM",
                        title="Bucket Not Using Customer-Managed Encryption",
                        description=f"Cloud Storage bucket {bucket_name} is not using customer-managed encryption keys",
                        cvss_score=5.0,
                        cve_id=None,
                        affected_resource=bucket_name,
                        resource_type="CloudStorage",
                        project_id=project_id,
                        zone='global',
                        detection_date=datetime.now(),
                        remediation="Configure customer-managed encryption keys (CMEK) for the bucket",
                        references=["https://cloud.google.com/storage/docs/encryption/customer-managed-keys"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check retention policy
                if not bucket.retention_policy:
                    vuln = Vulnerability(
                        id=f"GCS-{bucket_name}-NO-RETENTION",
                        severity="LOW",
                        title="No Retention Policy Configured",
                        description=f"Cloud Storage bucket {bucket_name} does not have a retention policy",
                        cvss_score=3.0,
                        cve_id=None,
                        affected_resource=bucket_name,
                        resource_type="CloudStorage",
                        project_id=project_id,
                        zone='global',
                        detection_date=datetime.now(),
                        remediation="Configure retention policy for compliance requirements",
                        references=["https://cloud.google.com/storage/docs/bucket-lock"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning Cloud Storage buckets: {e}")
        
        return vulnerabilities
    
    async def scan_gke_clusters(self, project_id: str) -> List[Vulnerability]:
        """Scan GKE clusters for vulnerabilities"""
        logger.info(f"Scanning GKE clusters in project: {project_id}")
        vulnerabilities = []
        
        try:
            # List all GKE clusters
            parent = f"projects/{project_id}/locations/-"
            clusters = self.container_client.list_clusters(parent=parent)
            
            for cluster in clusters.clusters:
                cluster_name = cluster.name
                location = cluster.location
                
                # Check for private cluster
                if not cluster.private_cluster_config.enable_private_nodes:
                    vuln = Vulnerability(
                        id=f"GKE-{cluster_name}-PUBLIC-NODES",
                        severity="HIGH",
                        title="GKE Cluster with Public Nodes",
                        description=f"GKE cluster {cluster_name} does not have private nodes enabled",
                        cvss_score=7.5,
                        cve_id=None,
                        affected_resource=cluster_name,
                        resource_type="GKE",
                        project_id=project_id,
                        zone=location,
                        detection_date=datetime.now(),
                        remediation="Enable private nodes for the GKE cluster",
                        references=["https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check workload identity
                if not cluster.workload_identity_config:
                    vuln = Vulnerability(
                        id=f"GKE-{cluster_name}-NO-WORKLOAD-IDENTITY",
                        severity="MEDIUM",
                        title="Workload Identity Not Enabled",
                        description=f"GKE cluster {cluster_name} does not have Workload Identity enabled",
                        cvss_score=6.0,
                        cve_id=None,
                        affected_resource=cluster_name,
                        resource_type="GKE",
                        project_id=project_id,
                        zone=location,
                        detection_date=datetime.now(),
                        remediation="Enable Workload Identity for better security",
                        references=["https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check binary authorization
                if not cluster.binary_authorization.evaluation_mode == "PROJECT_SINGLETON_POLICY_ENFORCE":
                    vuln = Vulnerability(
                        id=f"GKE-{cluster_name}-NO-BINARY-AUTH",
                        severity="MEDIUM",
                        title="Binary Authorization Not Enforced",
                        description=f"GKE cluster {cluster_name} does not enforce Binary Authorization",
                        cvss_score=6.5,
                        cve_id=None,
                        affected_resource=cluster_name,
                        resource_type="GKE",
                        project_id=project_id,
                        zone=location,
                        detection_date=datetime.now(),
                        remediation="Enable and configure Binary Authorization",
                        references=["https://cloud.google.com/binary-authorization/docs/overview"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check shielded nodes
                if not cluster.shielded_nodes.enabled:
                    vuln = Vulnerability(
                        id=f"GKE-{cluster_name}-NO-SHIELDED-NODES",
                        severity="MEDIUM",
                        title="Shielded Nodes Not Enabled",
                        description=f"GKE cluster {cluster_name} does not have Shielded Nodes enabled",
                        cvss_score=6.0,
                        cve_id=None,
                        affected_resource=cluster_name,
                        resource_type="GKE",
                        project_id=project_id,
                        zone=location,
                        detection_date=datetime.now(),
                        remediation="Enable Shielded Nodes for improved security",
                        references=["https://cloud.google.com/kubernetes-engine/docs/how-to/shielded-gke-nodes"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check release channel
                if cluster.release_channel.channel == "REGULAR":
                    vuln = Vulnerability(
                        id=f"GKE-{cluster_name}-REGULAR-CHANNEL",
                        severity="LOW",
                        title="Using Regular Release Channel",
                        description=f"GKE cluster {cluster_name} is using the regular release channel instead of stable",
                        cvss_score=4.0,
                        cve_id=None,
                        affected_resource=cluster_name,
                        resource_type="GKE",
                        project_id=project_id,
                        zone=location,
                        detection_date=datetime.now(),
                        remediation="Consider using Stable release channel for production",
                        references=["https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning GKE clusters: {e}")
        
        return vulnerabilities
    
    async def scan_vpc_networks(self, project_id: str) -> List[Vulnerability]:
        """Scan VPC networks for misconfigurations"""
        logger.info(f"Scanning VPC networks in project: {project_id}")
        vulnerabilities = []
        
        try:
            # Use compute client to list networks
            compute_service = googleapiclient.discovery.build('compute', 'v1', credentials=self.credentials)
            
            # List networks
            networks_result = compute_service.networks().list(project=project_id).execute()
            
            for network in networks_result.get('items', []):
                network_name = network['name']
                
                # Check for default network
                if network_name == 'default':
                    vuln = Vulnerability(
                        id=f"VPC-{network_name}-DEFAULT-NETWORK",
                        severity="MEDIUM",
                        title="Using Default VPC Network",
                        description=f"Project {project_id} is using the default VPC network",
                        cvss_score=5.0,
                        cve_id=None,
                        affected_resource=network_name,
                        resource_type="VPC",
                        project_id=project_id,
                        zone='global',
                        detection_date=datetime.now(),
                        remediation="Create custom VPC networks instead of using default",
                        references=["https://cloud.google.com/vpc/docs/vpc#default-network"],
                        category="MISCONFIGURATION"
                    )
                    vulnerabilities.append(vuln)
                
                # Check for overly permissive firewall rules
                firewall_result = compute_service.firewalls().list(project=project_id).execute()
                
                for firewall in firewall_result.get('items', []):
                    # Check if firewall is associated with this network
                    if firewall['network'].endswith(f'/global/networks/{network_name}'):
                        # Check for allow all rules
                        if '0.0.0.0/0' in firewall.get('sourceRanges', []):
                            if 'tcp' in firewall.get('allowed', [{}])[0] and '22' in firewall['allowed'][0]['ports']:
                                vuln = Vulnerability(
                                    id=f"VPC-{network_name}-SSH-OPEN",
                                    severity="CRITICAL",
                                    title="SSH Open to Internet",
                                    description=f"Firewall rule {firewall['name']} allows SSH from anywhere",
                                    cvss_score=9.8,
                                    cve_id=None,
                                    affected_resource=firewall['name'],
                                    resource_type="Firewall",
                                    project_id=project_id,
                                    zone='global',
                                    detection_date=datetime.now(),
                                    remediation="Restrict SSH access to specific IP ranges",
                                    references=["https://cloud.google.com/vpc/docs/firewalls"],
                                    category="MISCONFIGURATION"
                                )
                                vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning VPC networks: {e}")
        
        return vulnerabilities
    
    async def scan_iam_policies(self, project_id: str) -> List[Vulnerability]:
        """Scan IAM policies for misconfigurations"""
        logger.info(f"Scanning IAM policies in project: {project_id}")
        vulnerabilities = []
        
        try:
            # Get IAM policy for the project
            resource = f"projects/{project_id}"
            policy = self.asset_client.get_iam_policy(request={"resource": resource})
            
            # Check for overly permissive roles
            sensitive_roles = {
                'roles/owner',
                'roles/editor', 
                'roles/viewer',
                'roles/iam.serviceAccountAdmin',
                'roles/iam.serviceAccountKeyAdmin',
                'roles/cloudkms.admin',
                'roles/secretmanager.admin'
            }
            
            for binding in policy.bindings:
                role = binding.role
                
                # Check for sensitive roles assigned to allUsers or allAuthenticatedUsers
                if role in sensitive_roles:
                    for member in binding.members:
                        if member in ['allUsers', 'allAuthenticatedUsers']:
                            vuln = Vulnerability(
                                id=f"IAM-{project_id}-PUBLIC-{role.replace('/', '-')}",
                                severity="CRITICAL",
                                title=f"Public Access to {role}",
                                description=f"Role {role} is assigned to {member} in project {project_id}",
                                cvss_score=10.0,
                                cve_id=None,
                                affected_resource=project_id,
                                resource_type="IAM",
                                project_id=project_id,
                                zone='global',
                                detection_date=datetime.now(),
                                remediation=f"Remove {member} from role {role}",
                                references=["https://cloud.google.com/iam/docs/overview"],
                                category="MISCONFIGURATION"
                            )
                            vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error scanning IAM policies: {e}")
        
        return vulnerabilities

#     async def get_scc_vulnerability_assessments(self):
#     """Get vulnerability assessments from SCC"""
#     findings = []
    
#     # Use SCC to get vulnerability assessments
#     client = securitycenter_v1.SecurityCenterClient()
    
#     # List all vulnerability findings
#     request = securitycenter_v1.ListFindingsRequest(
#         parent=f"organizations/{self.org_id}/sources/-",
#         filter='category:"VULNERABILITY" AND state="ACTIVE"',
#         page_size=1000
#     )
    
#     for finding in client.list_findings(request=request):
#         # Process SCC findings
#         findings.append(self.convert_scc_finding(finding))
    
#     return findings

# async def export_to_scc(self, vulnerabilities):
#     """Export custom findings to Security Command Center"""
#     client = securitycenter_v1.SecurityCenterClient()
    
#     for vuln in vulnerabilities:
#         # Create finding
#         finding = securitycenter_v1.Finding(
#             name=f"{self.parent}/findings/{vuln.id}",
#             parent=self.parent,
#             resource_name=vuln.affected_resource,
#             category=vuln.category,
#             state="ACTIVE",
#             severity=vuln.severity,
#             event_time=datetime.now().isoformat() + "Z",
#             source_properties={
#                 "cvss_score": str(vuln.cvss_score),
#                 "remediation": vuln.remediation,
#                 "scanner_name": "Custom Vulnerability Scanner"
#             }
#         )
        
#         # Create or update finding
#         client.create_finding(
#             parent=self.parent,
#             finding_id=vuln.id,
#             finding=finding
#         )
    
    async def get_security_command_center_findings(self) -> List[Vulnerability]:
        """Get findings from Security Command Center"""
        logger.info("Fetching Security Command Center findings")
        vulnerabilities = []
        
        try:
            # Build parent path
            if self.config.get('organization_id'):
                parent = f"organizations/{self.config['organization_id']}"
            else:
                parent = f"projects/{self.project_id}"
            
            # List active findings
            request = securitycenter_v1.ListFindingsRequest(
                parent=f"{parent}/sources/-",
                filter="state=\"ACTIVE\"",
                page_size=1000
            )
            
            findings = self.security_center_client.list_findings(request=request)
            
            for finding in findings:
                # Convert SCC finding to our Vulnerability format
                vuln = Vulnerability(
                    id=finding.finding.name,
                    severity=finding.finding.severity,
                    title=finding.finding.category,
                    description=finding.finding.description,
                    cvss_score=self.extract_cvss_score(finding.finding),
                    cve_id=self.extract_cve_id(finding.finding),
                    affected_resource=finding.finding.resource_name,
                    resource_type=self.extract_resource_type(finding.finding.resource_name),
                    project_id=self.project_id,
                    zone=self.extract_zone(finding.finding.resource_name),
                    detection_date=datetime.now(),
                    remediation=finding.finding.recommendation,
                    references=[finding.finding.source_properties.get("Reference", "")],
                    category="VULNERABILITY"
                )
                vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error fetching Security Command Center findings: {e}")
        
        return vulnerabilities
    
    def extract_cvss_score(self, finding) -> float:
        """Extract CVSS score from SCC finding"""
        try:
            return float(finding.source_properties.get("cvssv3_score", 0.0))
        except:
            return 0.0
    
    def extract_cve_id(self, finding) -> Optional[str]:
        """Extract CVE ID from SCC finding"""
        return finding.source_properties.get("cve")
    
    def extract_resource_type(self, resource_name: str) -> str:
        """Extract resource type from resource name"""
        if 'instances' in resource_name:
            return 'ComputeEngine'
        elif 'buckets' in resource_name:
            return 'CloudStorage'
        elif 'datasets' in resource_name:
            return 'BigQuery'
        elif 'clusters' in resource_name:
            return 'GKE'
        else:
            return 'Unknown'
    
    def extract_zone(self, resource_name: str) -> str:
        """Extract zone from resource name"""
        parts = resource_name.split('/')
        for i, part in enumerate(parts):
            if part in ['zones', 'locations'] and i + 1 < len(parts):
                return parts[i + 1]
        return 'global'

class GCPReportGenerator:
    """Generate reports for GCP vulnerabilities"""
    
    def __init__(self, report_data: Dict):
        self.report_data = report_data
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def generate_html(self) -> str:
        """Generate HTML report with GCP-specific styling"""
        html_template = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>GCP Vulnerability Scan Report - {self.timestamp}</title>
            <style>
                body {{ font-family: 'Google Sans', Arial, sans-serif; margin: 40px; background-color: #f8f9fa; }}
                .header {{ background: linear-gradient(135deg, #4285f4, #34a853); color: white; padding: 30px; border-radius: 10px; }}
                .gcp-badge {{ background-color: #4285f4; color: white; padding: 5px 10px; border-radius: 4px; font-size: 12px; }}
                .summary {{ background-color: white; padding: 25px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
                .critical {{ color: #ea4335; font-weight: bold; border-left: 4px solid #ea4335; padding-left: 10px; }}
                .high {{ color: #fbbc04; border-left: 4px solid #fbbc04; padding-left: 10px; }}
                .medium {{ color: #f29900; border-left: 4px solid #f29900; padding-left: 10px; }}
                .low {{ color: #34a853; border-left: 4px solid #34a853; padding-left: 10px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
                th {{ background-color: #4285f4; color: white; padding: 15px; text-align: left; }}
                td {{ padding: 12px; border-bottom: 1px solid #e0e0e0; }}
                tr:hover {{ background-color: #f1f8ff; }}
                .resource-type {{ background-color: #e8f0fe; padding: 3px 8px; border-radius: 12px; font-size: 12px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>ðŸ”’ GCP Security Assessment Report</h1>
                <p>Google Cloud Platform Vulnerability Scan</p>
                <p>Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            </div>
            
            <div class="summary">
                <h2>ðŸ“Š Executive Summary</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div style="text-align: center; padding: 20px; background: #f1f8ff; border-radius: 8px;">
                        <h3 style="color: #4285f4; font-size: 36px; margin: 0;">{self.report_data['summary']['total_vulnerabilities']}</h3>
                        <p>Total Findings</p>
                    </div>
                    <div style="text-align: center; padding: 20px; background: #fef2f2; border-radius: 8px;">
                        <h3 style="color: #ea4335; font-size: 36px; margin: 0;">{self.report_data['summary']['by_severity'].get('CRITICAL', 0)}</h3>
                        <p>Critical</p>
                    </div>
                    <div style="text-align: center; padding: 20px; background: #fff8e1; border-radius: 8px;">
                        <h3 style="color: #fbbc04; font-size: 36px; margin: 0;">{self.report_data['summary']['by_severity'].get('HIGH', 0)}</h3>
                        <p>High</p>
                    </div>
                </div>
                
                <h3>ðŸ“ˆ Distribution by Resource Type</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 15px 0;">
                    {"".join(f'<span class="resource-type">{rtype}: {count}</span>' 
                      for rtype, count in list(self.report_data['summary']['by_resource_type'].items())[:8])}
                </div>
                
                <h3>ðŸ·ï¸ Projects Scanned</h3>
                <p>{', '.join(self.report_data['summary']['projects_scanned'])}</p>
            </div>
            
            <div class="summary">
                <h2>ðŸ” Detailed Findings</h2>
                <table>
                    <tr>
                        <th>Severity</th>
                        <th>Resource</th>
                        <th>Type</th>
                        <th>Project</th>
                        <th>Finding</th>
                        <th>Category</th>
                    </tr>
                    {"".join(
                        f"<tr class='{finding['severity'].lower()}'>
                            <td><span class='gcp-badge'>{finding['severity']}</span></td>
                            <td><code>{finding['affected_resource']}</code></td>
                            <td><span class='resource-type'>{finding['resource_type']}</span></td>
                            <td>{finding['project_id']}</td>
                            <td>{finding['title']}</td>
                            <td>{finding['category']}</td>
                        </tr>"
                        for finding in self.report_data['detailed_findings'][:50]  # Limit to 50 for readability
                    )}
                </table>
                <p style="text-align: center; color: #5f6368;">
                    Showing {min(50, len(self.report_data['detailed_findings']))} of {len(self.report_data['detailed_findings'])} findings
                </p>
            </div>
            
            <div class="summary">
                <h2>ðŸŽ¯ Top Recommendations</h2>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    {"".join(
                        f"<div style='padding: 15px; border: 1px solid #dadce0; border-radius: 8px;'>
                            <h4 style='color: #ea4335; margin: 0 0 10px 0;'>{rec['priority']} Priority</h4>
                            <p><strong>{rec['resource_type']}</strong>: {rec['count']} findings</p>
                            <p style='color: #5f6368;'>{rec['action']}</p>
                        </div>"
                        for rec in self.report_data['recommendations'][:6]
                    )}
                </div>
            </div>
        </body>
        </html>
        """
        return html_template
    
    def generate_csv(self) -> str:
        """Generate CSV report"""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            'Severity', 'Project', 'Resource Type', 'Resource', 'Zone',
            'Title', 'Description', 'CVSS', 'CVE ID', 'Category',
            'Remediation', 'Detection Date'
        ])
        
        # Write data
        for finding in self.report_data['detailed_findings']:
            writer.writerow([
                finding['severity'],
                finding['project_id'],
                finding['resource_type'],
                finding['affected_resource'],
                finding['zone'],
                finding['title'],
                finding['description'][:200] if finding['description'] else '',
                finding['cvss_score'],
                finding['cve_id'] or '',
                finding['category'],
                finding['remediation'][:200] if finding['remediation'] else '',
                finding['detection_date']
            ])
        
        return output.getvalue()
    
    def generate_json(self) -> str:
        """Generate JSON report"""
        import json
        return json.dumps(self.report_data, indent=2, default=str)

class GCPNotificationManager:
    """Handle notifications for GCP scan results"""
    
    def __init__(self, config: Dict, project_id: str):
        self.config = config
        self.project_id = project_id
        
    def send_pubsub(self, topic_name: str, message: Dict):
        """Send notification via Pub/Sub"""
        try:
            topic_path = self.pubsub_client.topic_path(self.project_id, topic_name)
            
            # Publish message
            future = self.pubsub_client.publish(
                topic_path,
                json.dumps(message).encode('utf-8'),
                severity=message.get('severity', 'INFO'),
                scan_id=message.get('scan_id', '')
            )
            
            message_id = future.result()
            logger.info(f"Published message to {topic_name}: {message_id}")
            
        except Exception as e:
            logger.error(f"Failed to publish to Pub/Sub: {e}")
    
    def send_email(self, subject: str, body: str, attachments: List[Dict] = None):
        """Send email notification"""
        if 'email' not in self.config.get('notification_channels', []):
            return
        
        try:
            msg = MIMEMultipart()
            msg['From'] = self.config['email']['from']
            msg['To'] = ', '.join(self.config['email']['recipients'])
            msg['Subject'] = subject
            
            # Use HTML body
            msg.attach(MIMEText(body, 'html'))
            
            # Attach files
            if attachments:
                for attachment in attachments:
                    part = MIMEApplication(attachment['content'])
                    part.add_header('Content-Disposition', 'attachment',
                                  filename=attachment['filename'])
                    msg.attach(part)
            
            # Send email (using Gmail or SMTP)
            with smtplib.SMTP(self.config['email']['smtp_server'],
                            self.config['email']['smtp_port']) as server:
                server.starttls()
                server.login(self.config['email']['username'],
                           self.config['email']['password'])
                server.send_message(msg)
                
            logger.info("Email notification sent successfully")
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
    
    def send_all_notifications(self, report: Dict):
        """Send all configured notifications"""
        summary = report['summary']
        
        # Prepare Pub/Sub message
        pubsub_message = {
            'scan_id': f"scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            'timestamp': datetime.now().isoformat(),
            'project_id': self.project_id,
            'total_findings': summary['total_vulnerabilities'],
            'critical_count': summary['by_severity'].get('CRITICAL', 0),
            'high_count': summary['by_severity'].get('HIGH', 0),
            'severity': 'CRITICAL' if summary['by_severity'].get('CRITICAL', 0) > 0 else 'HIGH' if summary['by_severity'].get('HIGH', 0) > 0 else 'INFO'
        }
        
        # Send Pub/Sub notification
        self.send_pubsub('vulnerability-scan-results', pubsub_message)
        
        # Prepare email message
        email_body = f"""
        <h2>GCP Vulnerability Scan Report</h2>
        <p><strong>Scan Date:</strong> {summary['scan_date']}</p>
        <p><strong>Projects Scanned:</strong> {', '.join(summary['projects_scanned'])}</p>
        
        <h3>Summary</h3>
        <ul>
            <li>Total Findings: {summary['total_vulnerabilities']}</li>
            <li>Critical: {summary['by_severity'].get('CRITICAL', 0)}</li>
            <li>High: {summary['by_severity'].get('HIGH', 0)}</li>
            <li>Medium: {summary['by_severity'].get('MEDIUM', 0)}</li>
            <li>Low: {summary['by_severity'].get('LOW', 0)}</li>
        </ul>
        
        <h3>Top Resource Types</h3>
        <ul>
            {"".join(f'<li>{rtype}: {count}</li>' for rtype, count in list(summary['by_resource_type'].items())[:5])}
        </ul>
        
        <p><a href="{self.config.get('report_url', '#')}">View Detailed Report</a></p>
        """
        
        # Send email
        self.send_email(
            subject=f"GCP Security Scan Report - {summary['scan_date']}",
            body=email_body
        )

class BigQueryExporter:
    """Export findings to BigQuery for analytics"""
    
    def __init__(self, bigquery_client, dataset_id: str, table_id: str):
        self.bigquery_client = bigquery_client
        self.dataset_id = dataset_id
        self.table_id = table_id
        
    def export_findings(self, vulnerabilities: List[Vulnerability]):
        """Export vulnerabilities to BigQuery"""
        try:
            # Prepare rows for insertion
            rows = []
            for vuln in vulnerabilities:
                row = {
                    'scan_timestamp': datetime.now().isoformat(),
                    'finding_id': vuln.id,
                    'severity': vuln.severity,
                    'title': vuln.title,
                    'description': vuln.description,
                    'cvss_score': vuln.cvss_score,
                    'cve_id': vuln.cve_id,
                    'affected_resource': vuln.affected_resource,
                    'resource_type': vuln.resource_type,
                    'project_id': vuln.project_id,
                    'zone': vuln.zone,
                    'detection_date': vuln.detection_date.isoformat(),
                    'category': vuln.category,
                    'remediation': vuln.remediation,
                    'references': json.dumps(vuln.references)
                }
                rows.append(row)
            
            # Get table reference
            table_ref = self.bigquery_client.dataset(self.dataset_id).table(self.table_id)
            
            # Insert rows
            errors = self.bigquery_client.insert_rows_json(table_ref, rows)
            
            if errors:
                logger.error(f"BigQuery insert errors: {errors}")
            else:
                logger.info(f"Successfully exported {len(rows)} findings to BigQuery")
                
        except Exception as e:
            logger.error(f"Failed to export to BigQuery: {e}")

async def main():
    """Main execution function for GCP scanner"""
    logger.info("Starting GCP Vulnerability Scanner")
    
    try:
        # Initialize scanner
        scanner = GCPVulnerabilityScanner("config_gcp.yaml")
        
        # Run scans
        vulnerabilities = await scanner.scan_all_resources()
        
        # Generate report
        report_data = scanner.generate_report(vulnerabilities)
        
        # Generate report files
        report_gen = GCPReportGenerator(report_data)
        report_files = {
            'html': report_gen.generate_html(),
            'csv': report_gen.generate_csv(),
            'json': report_gen.generate_json()
        }
        
        # Store reports in Cloud Storage
        storage_client = storage.Client(project=scanner.project_id)
        bucket_name = scanner.config.get('gcs_bucket', f"vulnerability-reports-{scanner.project_id}")
        bucket = storage_client.bucket(bucket_name)
        
        timestamp = datetime.now().strftime("%Y/%m/%d/%H%M%S")
        
        # Upload reports
        blob = bucket.blob(f"reports/{timestamp}/report.html")
        blob.upload_from_string(report_files['html'], content_type='text/html')
        
        blob = bucket.blob(f"reports/{timestamp}/report.csv")
        blob.upload_from_string(report_files['csv'], content_type='text/csv')
        
        blob = bucket.blob(f"reports/{timestamp}/report.json")
        blob.upload_from_string(report_files['json'], content_type='application/json')
        
        logger.info(f"Reports uploaded to gs://{bucket_name}/reports/{timestamp}/")
        
        # Send notifications
        notifier = GCPNotificationManager(scanner.config, scanner.project_id)
        notifier.send_all_notifications(report_data)
        
        # Export to BigQuery if configured
        if scanner.config.get('export_to_bigquery', False):
            exporter = BigQueryExporter(
                scanner.bigquery_client,
                scanner.config['bigquery_dataset'],
                scanner.config['bigquery_table']
            )
            exporter.export_findings(vulnerabilities)
        
        # Create Cloud Monitoring metrics
        await scanner.create_monitoring_metrics(report_data)
        
        logger.info("GCP Vulnerability scanning completed successfully")
        
    except Exception as e:
        logger.error(f"Scanner failed: {e}")
        raise

def cloud_function_handler(request):
    """Google Cloud Function handler for scheduled execution"""
    asyncio.run(main())
    return json.dumps({"status": "completed"}), 200

if __name__ == "__main__":
    # Run locally
    asyncio.run(main())
